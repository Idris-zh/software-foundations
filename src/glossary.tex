\newglossaryentry{algebraic data type}
{
  name=\sl{algebraic data type},
  description={\todo{define}},
  % plural={algebraic data types},
  sort={algebraic data type}
}

\newglossaryentry{computation rule}
{
  name=\sl{computation rule},
  description={\todo{define}},
  % plural={computation rules},
  sort={computation rule}
}

\newglossaryentry{expression}
{
  name=\sl{expression},
  description={\todo{define}},
  % plural={expressions},
  sort={expression}
}

\newglossaryentry{first-class}
{
  name=\sl{first-class},
  description={\todo{define}},
  sort={first-class}
}

\newglossaryentry{fully certified}
{
  name=\sl{fully certified},
  description={\todo{define}},
  sort={fully certified}
}

\newglossaryentry{function type}
{
  name=\sl{function type},
  description={\todo{define}},
  % plural={function types},
  sort={function type}
}

\longnewglossaryentry{idris-add-clause}{
  name=\el{idris-add-clause},
  sort={idris-add-clause}
}
{
  \el{(idris-add-clause PROOF)}

  Add clauses to the declaration at point.
}

\longnewglossaryentry{idris-case-split}{
  name=\el{idris-case-split},
  sort={idris-case-split}
}
{
  \el{(idris-case-split)}

  Case split the pattern variable at point.
}

\longnewglossaryentry{idris-load-file}{
  name=\el{idris-load-file},
  sort={idris-load-file}
}
{
  \el{(idris-load-file &optional SET-LINE)}

  Pass the current bufferâ€™s file to the inferior Idris process.

  A prefix argument restricts loading to the current line.
}

\longnewglossaryentry{idris-proof-search}{
  name=\el{idris-proof-search},
  sort={idris-proof-search}
}
{
  \el{(idris-proof-search &optional ARG)}

  Invoke the proof search. A plain prefix argument causes the
  command to prompt for hints and recursion depth, while a numeric
  prefix argument sets the recursion depth directly.
}

\newglossaryentry{induction}
{
  name=\sl{induction},
  description={\todo{define}},
  sort={induction}
}

\newglossaryentry{inductive rule}
{
  name=\sl{inductive rule},
  description={\todo{define}},
  % plural={inductive rules},
  sort={inductive rule}
}

\newglossaryentry{module system}
{
  name=\sl{module system},
  description={\todo{define}},
  sort={module system}
}

\newglossaryentry{pattern matching}
{
  name=\sl{pattern matching},
  description={\todo{define}},
  sort={pattern matching}
}

\newglossaryentry{polymorphic type system}
{
  name=\sl{polymorphic type system},
  description={\todo{define}},
  % plural={polymorphic type systems},
  sort={pattern matching}
}

\newglossaryentry{structural recursion}
{
  name=\sl{structural recursion},
  description={\todo{define}},
  sort={structural recursion}
}

\newglossaryentry{syntax}
{
  name=\idr{syntax},
  description={\todo{define}},
  sort={syntax}
}

\newglossaryentry{tactic}
{
  name=\sl{tactic},
  description={\todo{define}},
  % plural={tactics},
  sort={tactic}
}

\newglossaryentry{type}
{
  name=\sl{type},
  description={\todo{define}},
  % plural={type},
  sort={type}
}

\newglossaryentry{wildcard pattern}
{
  name=\sl{wildcard pattern},
  description={\todo{define}},
  % plural={wildcard patterns},
  sort={wildcard pattern}
}
